---
title: "Einfache lineare Regression"
format:
  live-html:
    css: 
      - exams/webex.css
    include-after-body: exams/webex.js
webr:
  packages:
    - dplyr
    - ggplot2
    - haven
toc: true    
lang: de
---

{{< include _extensions/r-wasm/live/_knitr.qmd >}}

Die einfache lineare Regression ist ein sehr grundlegendes statistisches Modell: Einerseits können mit ihr sehr viele deskriptive, explorative und explanative Forschungsfragen beantwortet werden, andererseits ist sie die Grundlage für komplexere Modellierungen wie Strukturgleichungs- oder Mehrebenenmodelle. Daher ist es wichtig, die Grundlagen der einfachen linearen Regression zu verstehen.

## Grundidee
Die einfache lineare Regression modelliert die Beziehung zwischen einer »abhängigen Variable« $y$ (auch »Outcome«, »Response«, »Regressant«) und einer »unabhängigen Variable« $x$ (auch »Prädiktor«, »Regressor«) linear (und damit monoton siehe @fig-monoton-linear).

![Visualisierung (nicht-)monotoner und (nicht-)linearer Funktionen](img/monotonitaet.svg){#fig-monoton-linear}

Dabei werden zunächst keine Annahmen über die Verteilungen von $y$ und $x$ gemacht - beide Variablen sollten jedoch intervallskaliert interpretierbar sein (siehe @fig-xy-verteilung):

![Regression mit unterschiedlichen Verteilungen in $x$ und $y$](img/verteilungen-av-uv.svg){#fig-xy-verteilung}

## Geometrische Repräsentation

Jedes Modell einer einfachen linearen Regression ist durch die Annahme der Linearität und die Festlegung eines Punktes und einer Steigung (oder zweier Punkte) eindeutig bestimmt. Für vorliegende Datenreihen von $x$ und $y$ wird die Regressiongerade meist so bestimmt, dass die Summe der Residuenquadrate möglichst klein wird:

```{=html}
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Einfache Lineare Regression</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,300;0,400;0,600;0,700;1,300;1,400;1,600;1,700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 16px;
            line-height: 1.5;
            margin: 0;
            padding: 10px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* h1 {
            font-family: 'Source Sans Pro', sans-serif;
            font-weight: 700;
            color: #267326;
            line-height: 1.2;
            margin-bottom: 10px;
            font-size: clamp(20px, 5vw, 28px);
            text-align: center;
        } */
        
        .reg-container {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 100%;
        }
        
        canvas {
            border: 2px solid #ddd;
            cursor: crosshair;
            display: block;
            margin: 15px auto;
            background: white;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }
        
        .reg-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .reg-button {
            padding: 10px 15px;
            font-size: 13px;
            font-family: 'Source Sans Pro', sans-serif;
            font-weight: 400;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #267326;
            color: white;
            transition: background-color 0.3s;
            white-space: nowrap;
            flex: 1 1 auto;
            min-width: 120px;
        }
        
        .reg-button:hover {
            background-color: #1f5c1f;
        }
        
        .reg-button.reg-secondary {
            background-color: #d77d00;
        }
        
        .reg-button.reg-secondary:hover {
            background-color: #b86a00;
        }
        
        .reg-button.reg-danger {
            background-color: #f44336;
        }
        
        .reg-button.reg-danger:hover {
            background-color: #da190b;
        }
        
        .reg-info-panel {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid #267326;
        }
        
        .reg-equation {
            font-size: clamp(14px, 3.5vw, 18px);
            font-weight: bold;
            color: #267326;
            margin: 10px 0;
            font-family: 'Roboto Mono', monospace;
            word-break: break-word;
        }
        
        .reg-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .reg-stat-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .reg-stat-label {
            font-weight: bold;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        
        .reg-stat-value {
            font-size: 16px;
            color: #333;
            margin-top: 5px;
        }
        
        .reg-checkbox-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .reg-checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }
        
        input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        /* Mobile Optimierungen */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .reg-container {
                padding: 10px;
                border-radius: 5px;
            }
            
            canvas {
                margin: 10px auto;
            }
            
            .reg-controls {
                gap: 8px;
            }
            
            .reg-button {
                font-size: 12px;
                padding: 8px 12px;
                min-width: 100px;
            }
            
            .reg-checkbox-container {
                gap: 10px;
            }
            
            .reg-checkbox-label {
                font-size: 13px;
            }
            
            .reg-checkbox-label span {
                display: none;
            }
            
            .reg-checkbox-label::after {
                content: attr(data-short);
            }
        }
        
        @media (max-width: 480px) {
            .reg-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .reg-button {
                width: 100%;
                min-width: auto;
            }
            
            .reg-checkbox-container {
                justify-content: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="reg-container">
        <div class="reg-checkbox-container">
            <label class="reg-checkbox-label" data-short="Linie">
                <input type="checkbox" id="showLine" checked>
                <span>Regressionsgerade</span>
            </label>
            <label class="reg-checkbox-label" data-short="b₀">
                <input type="checkbox" id="showIntercept" checked>
                <span>Intercept</span>
            </label>
            <label class="reg-checkbox-label" data-short="b₁">
                <input type="checkbox" id="showSlope" checked>
                <span>Slope</span>
            </label>
            <label class="reg-checkbox-label" data-short="Resid.">
                <input type="checkbox" id="showResiduals">
                <span>Residuen</span>
            </label>
            <label class="reg-checkbox-label" data-short="Resid.²">
                <input type="checkbox" id="showSquares">
                <span>Quadrierte Residuen</span>
            </label>
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="reg-controls">
            <button class="reg-button" onclick="addRandomPoint()">Zufälligen Punkt hinzufügen</button>
            <button class="reg-button reg-secondary" onclick="addMultiplePoints()">10 Punkte hinzufügen</button>
            <button class="reg-button reg-danger" onclick="clearPoints()">Alle Punkte löschen</button>
        </div>
        
        <div class="reg-info-panel">
            <div class="reg-equation" id="equation">Fügen Sie Punkte hinzu</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let points = [];
        let draggedPoint = null;
        let offsetX = 0;
        let offsetY = 0;
        
        // Responsive canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 30);
            
            // Set canvas to square to maintain 1:1 aspect ratio for plot area
            canvas.width = maxWidth;
            canvas.height = maxWidth; // Square canvas for 1:1 aspect ratio
            
            updateCanvasDimensions();
            
            // Only redraw if we already have initialized
            if (points.length > 0 || canvas.hasAttribute('data-initialized')) {
                draw();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Canvas settings (will be updated dynamically)
        let padding = 60;
        let plotWidth = 0;
        let plotHeight = 0;
        
        // Update canvas dimensions
        function updateCanvasDimensions() {
            padding = Math.max(40, canvas.width * 0.075);
            
            // Use the smaller dimension to ensure both axes fit
            const availableSize = Math.min(canvas.width, canvas.height) - 2 * padding;
            plotWidth = availableSize;
            plotHeight = availableSize;
        }
        
        // Initialize dimensions
        updateCanvasDimensions();
        
        // Coordinate system range
        let xMin = -5, xMax = 5;
        let yMin = -5, yMax = 5;
        
        // Convert canvas coordinates to plot coordinates
        function canvasToPlot(canvasX, canvasY) {
            updateCanvasDimensions();
            const x = xMin + (canvasX - padding) / plotWidth * (xMax - xMin);
            const y = yMax - (canvasY - padding) / plotHeight * (yMax - yMin);
            return { x, y };
        }
        
        // Convert plot coordinates to canvas coordinates
        function plotToCanvas(x, y) {
            const canvasX = padding + (x - xMin) / (xMax - xMin) * plotWidth;
            const canvasY = padding + (yMax - y) / (yMax - yMin) * plotHeight;
            return { canvasX, canvasY };
        }
        
        // Calculate linear regression
        function calculateRegression() {
            if (points.length < 2) return null;
            
            const n = points.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumXY += p.x * p.y;
                sumX2 += p.x * p.x;
                sumY2 += p.y * p.y;
            });
            
            const meanX = sumX / n;
            const meanY = sumY / n;
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = meanY - slope * meanX;
            
            // Calculate correlation coefficient
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            const r = denominator === 0 ? 0 : numerator / denominator;
            const r2 = r * r;
            
            // Calculate sum of squared residuals
            let sumSquaredResiduals = 0;
            points.forEach(p => {
                const predicted = slope * p.x + intercept;
                const residual = p.y - predicted;
                sumSquaredResiduals += residual * residual;
            });
            
            return { slope, intercept, r, r2, sumSquaredResiduals };
        }
        
        // Draw the coordinate system
        function drawAxes() {
            updateCanvasDimensions();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = Math.max(1, canvas.width / 400);
            const fontSize = Math.max(10, canvas.width / 60);
            ctx.font = fontSize + 'px Arial';
            ctx.fillStyle = '#333';
            
            // Draw axes
            ctx.beginPath();
            const origin = plotToCanvas(0, 0);
            
            // X-axis
            ctx.moveTo(padding, origin.canvasY);
            ctx.lineTo(canvas.width - padding, origin.canvasY);
            
            // Y-axis
            ctx.moveTo(origin.canvasX, padding);
            ctx.lineTo(origin.canvasX, canvas.height - padding);
            ctx.stroke();
            
            // Draw tick marks and labels
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#999';
            ctx.fillStyle = '#666';
            
            // X-axis ticks
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                if (x === 0) continue;
                const pos = plotToCanvas(x, 0);
                ctx.beginPath();
                ctx.moveTo(pos.canvasX, origin.canvasY - 5);
                ctx.lineTo(pos.canvasX, origin.canvasY + 5);
                ctx.stroke();
                ctx.fillText(x.toString(), pos.canvasX - 5, origin.canvasY + 20);
            }
            
            // Y-axis ticks
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                if (y === 0) continue;
                const pos = plotToCanvas(0, y);
                ctx.beginPath();
                ctx.moveTo(origin.canvasX - 5, pos.canvasY);
                ctx.lineTo(origin.canvasX + 5, pos.canvasY);
                ctx.stroke();
                ctx.fillText(y.toString(), origin.canvasX - 25, pos.canvasY + 5);
            }
            
            // Axis labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('x', canvas.width - padding + 20, origin.canvasY);
            ctx.fillText('y', origin.canvasX, padding - 20);
        }
        
        // Draw points
        function drawPoints() {
            const pointRadius = Math.max(4, canvas.width / 130);
            points.forEach((point, index) => {
                const pos = plotToCanvas(point.x, point.y);
                
                ctx.beginPath();
                ctx.arc(pos.canvasX, pos.canvasY, pointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#267326';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = Math.max(1, canvas.width / 400);
                ctx.stroke();
            });
        }
        
        // Draw intercept point
        function drawIntercept() {
            if (!document.getElementById('showIntercept').checked) return;
            
            const regression = calculateRegression();
            if (!regression) return;
            
            const { intercept } = regression;
            const pos = plotToCanvas(0, intercept);
            
            // Draw intercept point
            ctx.beginPath();
            ctx.arc(pos.canvasX, pos.canvasY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            // Draw label
            ctx.fillStyle = '#d77d00';
            ctx.font = 'bold 14px Source Sans Pro';
            ctx.fillText('b₀ = ' + intercept.toFixed(2), pos.canvasX + 12, pos.canvasY - 8);
        }
        
        // Draw slope triangle
        function drawSlopeTriangle() {
            if (!document.getElementById('showSlope').checked) return;
            
            const regression = calculateRegression();
            if (!regression) return;
            
            const { slope, intercept } = regression;
            
            // Position triangle starting from x=1
            const x1 = 1;
            const x2 = 2;
            const y1 = slope * x1 + intercept;
            const y2 = slope * x2 + intercept;
            
            const p1 = plotToCanvas(x1, y1);
            const p2 = plotToCanvas(x2, y1);
            const p3 = plotToCanvas(x2, y2);
            
            // Draw triangle
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(p1.canvasX, p1.canvasY);
            ctx.lineTo(p2.canvasX, p2.canvasY);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(p2.canvasX, p2.canvasY);
            ctx.lineTo(p3.canvasX, p3.canvasY);
            ctx.stroke();
            
            // Hypotenuse (part of regression line - already drawn)
            
            // Labels
            ctx.fillStyle = '#2196F3';
            ctx.font = 'bold 13px Source Sans Pro';
            
            // Vertical label (b₁ = slope)
            const midY = (p2.canvasY + p3.canvasY) / 2;
            ctx.fillText('b₁ = ' + slope.toFixed(2), p2.canvasX + 8, midY);
        }
        
        // Draw regression line
        function drawRegressionLine() {
            if (!document.getElementById('showLine').checked) return;
            
            const regression = calculateRegression();
            if (!regression) return;
            
            const { slope, intercept } = regression;
            
            // Calculate line endpoints
            const y1 = slope * xMin + intercept;
            const y2 = slope * xMax + intercept;
            
            const start = plotToCanvas(xMin, y1);
            const end = plotToCanvas(xMax, y2);
            
            ctx.strokeStyle = '#267326';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start.canvasX, start.canvasY);
            ctx.lineTo(end.canvasX, end.canvasY);
            ctx.stroke();
        }
        
        // Draw residuals
        function drawResiduals() {
            const showResiduals = document.getElementById('showResiduals').checked;
            const showSquares = document.getElementById('showSquares').checked;
            
            if (!showResiduals && !showSquares) return;
            
            const regression = calculateRegression();
            if (!regression) return;
            
            const { slope, intercept } = regression;
            
            points.forEach(point => {
                const predictedY = slope * point.x + intercept;
                const residual = point.y - predictedY;
                
                const pointPos = plotToCanvas(point.x, point.y);
                const predPos = plotToCanvas(point.x, predictedY);
                
                if (showSquares && Math.abs(residual) > 0.01) {
                    // Draw square
                    const sideLength = Math.abs(pointPos.canvasY - predPos.canvasY);
                    ctx.fillStyle = 'rgba(244, 67, 54, 0.2)';
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 1;
                    
                    if (residual > 0) {
                        // Point is above the line - draw square to the right from point position
                        ctx.fillRect(pointPos.canvasX, pointPos.canvasY, sideLength, sideLength);
                        ctx.strokeRect(pointPos.canvasX, pointPos.canvasY, sideLength, sideLength);
                    } else {
                        // Point is below the line - draw square to the right from predicted position
                        ctx.fillRect(predPos.canvasX, predPos.canvasY, sideLength, sideLength);
                        ctx.strokeRect(predPos.canvasX, predPos.canvasY, sideLength, sideLength);
                    }
                } else if (showResiduals) {
                    // Draw line
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(pointPos.canvasX, pointPos.canvasY);
                    ctx.lineTo(predPos.canvasX, predPos.canvasY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
        }
        
        // Update display
        function updateDisplay() {
            const regression = calculateRegression();
            
            if (regression) {
                const { slope, intercept } = regression;
                document.getElementById('equation').textContent = 
                    `y = ${slope.toFixed(3)}x + ${intercept.toFixed(3)}`;
            } else {
                document.getElementById('equation').textContent = 
                    points.length === 0 ? 'Fügen Sie Punkte hinzu' : 'Mindestens 2 Punkte erforderlich';
            }
        }
        
        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawAxes();
            drawRegressionLine();
            drawSlopeTriangle();
            drawResiduals();
            drawPoints();
            drawIntercept();
            updateDisplay();
        }
        
        // Event handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            // Check if clicking on existing point
            for (let i = 0; i < points.length; i++) {
                const pos = plotToCanvas(points[i].x, points[i].y);
                const dist = Math.sqrt(Math.pow(canvasX - pos.canvasX, 2) + Math.pow(canvasY - pos.canvasY, 2));
                
                if (dist < 10) {
                    draggedPoint = i;
                    offsetX = canvasX - pos.canvasX;
                    offsetY = canvasY - pos.canvasY;
                    return;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (draggedPoint !== null) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left - offsetX;
                const canvasY = e.clientY - rect.top - offsetY;
                
                const plotCoords = canvasToPlot(canvasX, canvasY);
                
                // Snap to 0.5 grid
                plotCoords.x = Math.round(plotCoords.x * 2) / 2;
                plotCoords.y = Math.round(plotCoords.y * 2) / 2;
                
                points[draggedPoint] = plotCoords;
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            draggedPoint = null;
        });
        
        canvas.addEventListener('mouseleave', () => {
            draggedPoint = null;
        });
        
        // Touch event handlers für mobile Geräte
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const canvasX = touch.clientX - rect.left;
            const canvasY = touch.clientY - rect.top;
            
            // Check if touching existing point
            const touchRadius = Math.max(15, canvas.width / 50);
            for (let i = 0; i < points.length; i++) {
                const pos = plotToCanvas(points[i].x, points[i].y);
                const dist = Math.sqrt(Math.pow(canvasX - pos.canvasX, 2) + Math.pow(canvasY - pos.canvasY, 2));
                
                if (dist < touchRadius) {
                    draggedPoint = i;
                    offsetX = canvasX - pos.canvasX;
                    offsetY = canvasY - pos.canvasY;
                    return;
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedPoint !== null) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const canvasX = touch.clientX - rect.left - offsetX;
                const canvasY = touch.clientY - rect.top - offsetY;
                
                const plotCoords = canvasToPlot(canvasX, canvasY);
                
                // Snap to 0.5 grid
                plotCoords.x = Math.round(plotCoords.x * 2) / 2;
                plotCoords.y = Math.round(plotCoords.y * 2) / 2;
                
                points[draggedPoint] = plotCoords;
                draw();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            draggedPoint = null;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            draggedPoint = null;
        });
        
        // Generate random number from standard normal distribution (Box-Muller transform)
        function randomNormal() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }
        
        // Button functions
 function addRandomPoint() {
    const meanX = 0;
    const meanY = 0;
    const sdX = 3;
    const sdY = 3;
    
    let x = meanX + sdX * randomNormal();
    let y = meanY + sdY * randomNormal();
    
    // Clip to canvas bounds
    x = Math.max(xMin, Math.min(xMax, x));
    y = Math.max(yMin, Math.min(yMax, y));
    
    // Round to 0.5 increments (0, 0.5, 1, 1.5, 2, etc.)
    x = Math.round(x * 2) / 2;
    y = Math.round(y * 2) / 2;
    
    points.push({ x, y });
    draw();
}

function addMultiplePoints() {
    const meanX = 0;
    const meanY = 0;
    const sdX = 3;
    const sdY = 3;
    
    for (let i = 0; i < 10; i++) {
        let x = meanX + sdX * randomNormal();
        let y = meanY + sdY * randomNormal();
        
        // Clip to canvas bounds
        x = Math.max(xMin, Math.min(xMax, x));
        y = Math.max(yMin, Math.min(yMax, y));
        
        // Round to 0.5 increments (0, 0.5, 1, 1.5, 2, etc.)
        x = Math.round(x * 2) / 2;
        y = Math.round(y * 2) / 2;
        
        points.push({ x, y });
    }
    draw();
}
        
        function clearPoints() {
            points = [];
            draw();
        }
        
        // Checkbox event listeners
        document.getElementById('showLine').addEventListener('change', draw);
        document.getElementById('showIntercept').addEventListener('change', draw);
        document.getElementById('showSlope').addEventListener('change', draw);
        document.getElementById('showResiduals').addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('showLine').checked = true;
            }
            draw();
        });
        document.getElementById('showSquares').addEventListener('change', function() {
            if (this.checked) {
                document.getElementById('showLine').checked = true;
            }
            draw();
        });
        
        // Add initial points
        points = [
            { x: -3, y: -1.5 },
            { x: -1, y: 1.2 },
            { x: 2, y: -0.8 },
            { x: 4, y: 1.8 }
        ];
        
        // Mark as initialized and do initial setup
        canvas.setAttribute('data-initialized', 'true');
        resizeCanvas();
        draw();
    </script>
</body>
</html>
```

```{r}
#| echo: false
#| results: 'asis'
#| warning: false
#| label: fragen zu interkarive app lin reg
library(exams)
library(exams2forms)
exams2forms("exams/einfache-reg-rechteck.Rmd", n = 3)
```

## Algebraische Notation
![Begriffe in der algebraischen Notation](img/EinfLinRegression.svg){#fig-EinfLinRegression fig-align="left" width="400px"}

Um diese geometrische Repräsentation algebraisch zu notieren, müssen die folgenden Begriffe definiert werden (siehe auch @fig-EinfLinRegression)

-   $_i$ -- **Index** für die Beobachtungen (1 bis n). Damit sind z.B. $x_i$ und $y_i$ sind die Werte der unabhängigen und abhängigen Variable für die i-te Beobachtung.
-   $\hat{y}_i$ -- Durch die Regression **vorhergesagter Wert** der abhängigen Variable für die i-te Beobachtung. Der Punkt $\left(x_i, \hat{y}_i\right)$ liegt immer auf der Regressionsgeraden.
-   $\epsilon_i$ -- **Residuum** der i-ten Beobachtung. Das Residuum ist die Differenz zwischen dem beobachteten Wert $y_i$ und dem durch das Modell vorhergesagten Wert $\hat{y}_i$. 
-   $b_0$ -- **Achsenabschnitt** der Regressionsgeraden. Er ist der vorhergesagte Wert der abhängigen Variable, wenn die unabhängige Variable den Wert 0 annimmt.
-   $b_1$ -- **Steigung** der Regressionsgeraden. Sie gibt an, um wie viele Einheiten sich die abhängige Variable im Durchschnitt unterscheidet, wenn sich die unabhängige Variable um eine Einheit unterscheidet.

Die Beziehungen dieser Begriffe kann dann wie folgt notiert werden:

$$
y_i = b_0 + b_1 \cdot x_i + \varepsilon_i
$$ {#eq-regression}

$$
\hat{y}_i = b_0 + b_1 \cdot x_i
$$ {#eq-prediction}

Setzt man nun @eq-prediction in @eq-regression ein, so erhält man:

$$
y_i = \hat{y}_i + \varepsilon_i \Leftrightarrow
$$ {#eq-residual}

$$
y_i - \varepsilon_i= \hat{y}_i
$$

wonach der beobachtete Wert $y_i$ als Summe des durch das Modell vorhergesagten Wertes $\hat{y}_i$ und dem Residuum $\varepsilon_i$ dargestellt werden kann (siehe @fig-EinfLinRegression).

```{r}
#| echo: false
#| results: 'asis'
#| warning: false
#| label: fragen zu grundbegriffen lin reg
library(exams)
library(exams2forms)
exams2forms("exams/Grundbegriffe-Regression-erkennen.Rmd", n = 20)
```

## Stochastische Notation

Während sowohl die geometrische Repräsentation als auch die algebraische Notation das **Modell** mit seinen zu bestimmenden Parametern in den Fokus nehmen, betont die stochastische Schreibweise den **Prozess**, durch den die Daten generiert werden. Dabei wird angenommen, dass die abhängige Variable $y$ für jede Ausprägung der unabhängigen Variable $x$ einer bestimmten Wahrscheinlichkeitsverteilung mit bestimmten Parametern (z.B. Erwartungswert und Standardabweichung) folgt. In der einfachsten Form der linearen Regression wird angenommen, dass die abhängige Variable für jede Ausprägung der unabhängigen Variable einer Normalverteilung folgt, deren Erwartungswert $\mu$ durch die Regressionsgleichung bestimmt $\left(\mu = b_0 + b_1\cdot x \right)$ wird und deren Varianz konstant ist (Homoskedastizität).

$$
y_i \sim \mathcal{N}\left(b_0 + b_1 \cdot x_i, \sigma^2\right)
$$

![Visualisierung der Regression als bedingte Erwartungswerte](img/reg-as-cond-expectancies.svg){#fig-reg-as-cond-expectancies}


### Beispiel 1: Klassengröße und Matheleistung im Querschnitt

In diesem Beispiel wollen wir den Effekt der Klassengröße (`g3classsize`) auf die Mathematikleistung (`g3tmathss`) von Drittklässlern untersuchen. Die Daten stammen aus dem STAR-Experiment in Tennessee [@word1990], bei dem Schüler:innen zufällig auf Klassen mit unterschiedlicher Größe zugewiesen wurden. Wir verwenden hier zunächst nur die Daten jeweils eines Kindes pro Klasse und nur das dritte Schuljahr.
Zunächst werden die Daten geladen und je Klasse ein Mittelwert gebildet um Abhängigkeiten innerhalb der Klassen zu vermeiden.

::: callout-warning
Eine solche Aggregation von Daten ist in der Regel nicht empfehlenswert. In diesem Fall dient die Aggregation nur der Vereinfachung der Darstellung und Analyse.
:::
```{r}
#| label: bibs
#| warning: false
#| message: false

library(haven)      # für den Import der spss Daten
library(tidyverse)  # für Datenmanipulation und Visualisierung
library(brand.yml)  # für Anpassung der Plots an das Design des eBooks
```

```{r}
#| label: data-star
#| include: false
#| cache: true

```



```{r}
#| label: data-star2
#| warning: false
#| message: false
#| cache: true
#| result: hide
data_star <- read_sav(
  "data_star_workshop.sav"
)

data_star_subset <- data_star %>%
  group_by(g3tchid) %>%
  summarize(
    class_mean_g3tmathss = mean(g3tmathss, na.rm = T),
    g3classsize = mean(g3classsize, na.rm = T)
  ) %>%
  ungroup()
```

Zunächst wird die Beziehung zwischen Klassengröße und Mathematikleistung grafisch dargestellt.

```{r}
#| label: plot-star einfache lin reg
#| message: false
#| warning: false
data_star_subset %>%
    ggplot(aes(x = g3classsize, y = class_mean_g3tmathss)) +
    geom_point(alpha = 0.3) +
    geom_smooth(method = "lm", se = F) +
    theme_brand_ggplot2()
```

```{r}
#| echo: false
#| results: 'asis'
#| warning: false
#| label: erkenntnisinteresse-erkennen
library(exams)
library(exams2forms)
exams2forms("exams/g3classsize_g3tmathss_graph_sc.Rmd", n = 20)
```

Im folgenden Codefenster können Sie nun $b_0$ und $b_1$ der lineare Regression

$$
\text{class\_mean\_g3tmathss}_i = b_0 + b_1 \cdot \text{g3classsize}_i + \varepsilon_i
$$

schätzen und inferenzstatistisch absichern lassen. Nutzen Sie die gestuften Lösungshilfen um den Output zu bekommen, der es Ihnen erlaubt, die Fragen in der folgenden Übung zu beantworten.

```{webr}
#| setup: true
#| exercise:
#|   - einf lin reg classmean classsize
data_star <- read_sav(
  "https://raw.githubusercontent.com/sammerk/WinterSchoolZH/master/data_workshop.sav"
)

data_star_subset <- data_star %>%
  group_by(g3tchid) %>%
  summarize(
    class_mean_g3tmathss = mean(g3tmathss, na.rm = T),
    g3classsize = mean(g3classsize, na.rm = T)
  ) %>%
  ungroup()
```

```{webr}
#| exercise: einf lin reg classmean classsize

lm(class_mean_g3tmathss ~ g3classsize, 
   data = data_star_subset) %>%
  summary()
```

:::: {.hint exercise="einf lin reg classmean classsize"}
::: {.callout-note collapse="false"}
## Hinweis 1

Die klassische Funktion für die lineare Regression in R im `lm()`.
:::
::::

:::: {.hint exercise="einf lin reg classmean classsize"}
::: {.callout-note collapse="false"}
## Hinweis 2

Innerhalb von `lm()` wird die Regressionsformel angegeben, gefolgt von dem Datensatz mit dem Argument `data =`. In der Regressionsformel wird die abhängige Variable links vom Tilde-Zeichen `~` und die unabhängige Variable rechts davon angegeben; also z.B. `lm(class_mean_g3tmathss ~ g3classsize)`.
:::
::::

:::: {.solution exercise="einf lin reg classmean classsize"}
::: {.callout-tip collapse="false"}
## Lösung

Also kann der folgende Output genutzt werden, um die Fragen in der Übung zu beantworten:

```         
lm(class_mean_g3tmathss ~ g3classsize, #<1>
   data = data_star_subset) %>%        #<2>
  summary()                            #<3>            
```

1.  Die Regressionsformel, die die abhängige Variable `class_mean_g3tmathss` und die unabhängige Variable `g3classsize` spezifiziert.
2.  Der Datensatz, der die Variablen enthält.
3.  Die Funktion `summary()`, die die Punktschätzung der Parameter (`Estimate`) und die Inferenzstatistik (`Std. Error`, `t value`, `Pr(>|t|)`) der Regression anzeigt.

Der so generierte Output kann wie folgt interpretiert werden:

```         
Call:
lm(formula = class_mean_g3tmathss ~ g3classsize, data = data_star_subset)

Residuals:
   Min     1Q Median     3Q    Max 
-61.04 -13.59   0.11  13.49  73.18 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) 638.9148     5.4542  117.14  < 2e-16 ***   
g3classsize  -0.9891     0.2631   -3.76 0.000201 ***   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 21.81 on 332 degrees of freedom
  (3 observations deleted due to missingness)
Multiple R-squared:  0.04084,   Adjusted R-squared:  0.03795 
F-statistic: 14.14 on 1 and 332 DF,  p-value: 0.0002009         
```

1)  Der Achsenabschnitt `b_0` der Regressionsgeraden ist ungefähr 638.91. Der *p*-Wert zeigt bezieht sich auf die Nullhypothese $H_0:\;b_0 = 0$ mit der zweiseitigen Alternativhypothese $H_1:\;b_0 \neq 0$. Da der p-Wert kleiner als 0.05 ist, kann die Nullhypothese verworfen werden.
2)  Der Slope `b_1` der Regressionsgeraden ist ungefähr -0.99. Der *p*-Wert bezieht sich auf die Nullhypothese $H_0:\;b_1 = 0$ mit der zweiseitigen Alternativhypothese $H_1:\;b_1 \neq 0$. Da der p-Wert kleiner als 0.05 ist, kann die Nullhypothese verworfen werden. Man würde dies als *signifikanten Effekt* der Klassengröße auf die Matheleistung beschreiben.
:::
::::

## Standardisierte Effektstärken der einfachen lineare Regression

### Binomial Effect Size Display

Das Binomial Effect Size Display [@rosenthal2005] ist eine Methode, um die standardisierte Effektstärke einer einfachen linearen Regression in einer auch für Laien verständlichen Weise zu präsentieren. Es basiert auf einer ähnlichen Idee wie der Fechner Index der Korrelation [@fechner1897]: Während bei der Interpretation der einfachen linearen Regression die Regressionsgewichte $b_0$ und $b_1$ (u.a.) von der Streuung der unabhängigen und abhängigen Variable abhängen, umgeht das Binomial Effect Size Display dieses Problem, indem es beide Variablen in über- und unterdurchschnittliche Hälften einteilt. Somit fällt jeder Datenpunkte in eine der vier Kategorien (siehe auch @fig-besd).

1.  **über**durchschnittlich in **x** & **über**durchschnittlich in **y**
2.  **über**durchschnittlich in **x** & **unter**durchschnittlich in **y**
3.  **unter**durchschnittlich in **x** & **über**durchschnittlich in **y**
4.  **unter**durchschnittlich in **x** & **unter**durchschnittlich in **y**

Bildet man nun die **Anteile** der Datenpunkte in jeder dieser vier Kategorien, entsprechen diese einer standardisierten Effektstärke.

![Konstruktion des Binomial Effect Size Display](img/besd.svg){#fig-besd width="56%" fig-align="left"}

```{r}
#| echo: false
#| results: 'asis'
#| warning: false
#| label: besd erkennen
library(exams)
library(exams2forms)
exams2forms("exams/Scatterplot-BESD-zuordnen.Rmd", n = 4)
```

### Standardisierte Regressionsgewichte

Ändert man bei einer Regression die Einheiten der abhängigen oder unabhängigen Variable, ändern sich die Regressionsgewichte $b_0$ und $b_1$ ebenfalls, was den Vergleich der Effektgröße über verschiedene Studien hinweg (mit verschiedenen Maßen) schwierig macht (siehe @fig-standardized-regression links/mitte). Eine Lösung für dieses Problem bietet die sogenannte standardisierte Regression. In dieser z-standardisiert man die abhängige und unabhängige Variable, setzt also deren Mittelwert auf $0$ und die Standardabweichung auf 1.

![Abhängingkeit der Regressionsgewichte $b_0$ und $b_1$ von der Maßeinheit sowie Standardisierte Regression (rechts)](img/reg-abh-masseinheit.jpg){#fig-standardized-regression width="100%" fig-align="left"}

Da die Regressionsgerade immer den »Schwerpunkt der Daten« $\left(\bar{x}, \bar{y}\right) = (\text{Mittelwert UV}, \text{MittelwertAV})$ enthält, entspricht der Achsenabschnitt $\beta_0$ in der standardisierten Regression immer $0$. Die Steigung $\beta_1$ gibt nun an, um wie viele Standardabweichungen sich die abhängige Variable im Durchschnitt in zwei Gruppen unterscheidet, wenn sich die unabhängige Variable um eine Standardabweichung unterscheidet. Das standardisierte Regressionsgewicht $\beta_1$ entspricht dabei exakt der Produkt-Moment-Korrelation (Pearson Korrelation) $r$ zwischen der abhängigen und unabhängigen Variable (siehe @fig-standardized-regression rechts).

In manchen Fällen kann es auch Sinn machen nur die unabhängige Variable zu standardisieren -- etwa wenn die unabhängige Variable eine dummykodierte Gruppenzugehörigkeit enkodiert, also nur 0 (Gruppe A) und 1 (Gruppe B) annehmen kann. Es lässt sich zeigen, dass eine Regressionsgerade in diesem Fall immer die beiden Gruppenmittelwerte $\left(0,\bar{y}_{Gruppe_0}\right)$ und $\left(1,\bar{y}_{Gruppe_1}\right)$ durchläuft. Dadurch entspricht der horizontale Teil des Steigungsdreickes (Länge 1) dem »Wechsel« von der Gruppe 0 in die Gruppe 1. Der senkrechte Teil des Steigungsdreicks $b_1$ ist dann die Gruppelmittelwertsdifferenz $\bar{y}_{Gruppe_1} - \bar{y}_{Gruppe_0}$. Da die abhängige Variable nach der Standardisierung die Maßeinheit 1 hat, entspricht $b_1$ in diesem Fall der standardisierten Mittelwertsdifferenz $\text{Cohen's }d=\frac{\bar{y}_{Gruppe_1} - \bar{y}_{Gruppe_0}}{SD} = b_1$  zwischen den beiden Gruppen (siehe @fig-dummy-regression).

![Dummy-Regression mit standardisierter abhängiger Variable](img/dummy-regression.svg){#fig-dummy-regression width="60%" fig-align="left"}

### Der Determinationskoeffizient $R^2$
Der Determinationskoeffizient $R^2$ gibt an, welcher Anteil der Varianz der abhängigen Variable durch die unabhängige Variable erklärt werden kann. 
Die folgende interaktive Visualisierung demonstriert die folgenden Tatsachen:

1) Der [**Mittelwert der abhängigen Variable**]{.text-secondary} $\bar{y}$ ist gleich dem Mittelwert der prädizierten Werte $\bar{\hat{y}}=\bar{y}$.
2) Die [**Varianz der abhängigen Variable**]{.text-secondary} $y$ entspricht den mittleren quadrierten Abständen der Punkte zu deren Mittelwert (gestrichelte Linie) 
3) Die [**Varianz der prädizierte Werte**]{.text-primary} $\hat{y}$ entspricht den quadrierten Abständen dieser zu deren Mittelwert $\left(\bar{\hat{y}}=\bar{y}= \text{gestrichelte Linie}\right)$
4) Die [**Residuen**]{.text-tertiary} $\varepsilon$ haben einen Mittelwert von $\bar{\varepsilon}=0$
5) Die mittleren Residuenquadrate sind damit gleich der [**Varianz der Residuen**]{.text-tertiary}.

In der interaktiven Visualisierung kann man nun beobachten, dass die Summe der [**grünen**]{.text-primary} und [**blauen**]{.text-tertiary} Flächen immer der gesamten [**gelben**]{.text-secondary} Fläche entsprichen. Dies entspricht der Zerlegung der Gesamtvarianz der abhängigen Variable in die durch die Regression erklärte Varianz und die Residualvarianz:


$$
\definecolor{primary}{RGB}{38, 115, 38}
\definecolor{secondary}{RGB}{215,125,0}
\definecolor{tertiary}{RGB}{0,120,165}
$$

$$
\color{secondary}{\text{Var}(y)} \color{black}{=} \color{primary}{\text{Var}(\hat{y})} \color{black}{+} \color{tertiary}{\text{Var}(\varepsilon)} \\
$$
In englischen Lehrbüchern werden dafür oft die folgenden Begriffe dafür genutzt,
$$
\color{secondary}{\text{Total Sum of Squares}}\color{black} = \color{primary}{\text{Explained Sum of Squares}}+ \color{tertiary}{\text{Residual Sum of Squares}}
$$
welche dann wie folgt abgeküzt werden:
$$
\color{secondary}{\text{TSS}}= \color{primary}{\text{ESS}} + \color{tertiary}{\text{RSS}}
$$

Der Determinationskoeffizient $R^2$ gibt nun an, welcher Anteil der Gesamtvarianz durch die Regression erklärt werden kann:

$$
R^2 = \frac{\color{primary}{\text{ESS}}}{\color{secondary}{\text{TSS}}} = 1 - \frac{\color{tertiary}{\text{RSS}}}{\color{secondary}{\text{TSS}}}
$$

````{=html}
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R² Visualisierung</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,300;0,400;0,600;0,700;1,300;1,400;1,600;1,700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 16px;
            line-height: 1.5;
            margin: 0;
            padding: 10px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .r2-h1 {
            font-family: 'Source Sans Pro', sans-serif;
            font-weight: 700;
            color: #267326;
            line-height: 1.2;
            margin-bottom: 10px;
            font-size: clamp(20px, 5vw, 28px);
            text-align: center;
        }
        
        .r2-container {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 100%;
        }
        
        canvas {
            border: 2px solid #ddd;
            cursor: crosshair;
            display: block;
            margin: 15px auto;
            background: white;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }
        
        .r2-checkbox-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .r2-checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }
        
        input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .r2-info-panel {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid #267326;
        }
        
        .r2-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
        }
        
        .r2-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .r2-stat-label {
            font-weight: bold;
            color: #267326;
        }
        
        .r2-stat-value {
            color: #333;
        }
        
        .r2-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .r2-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .r2-legend-box {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .r2-container {
                padding: 10px;
                border-radius: 5px;
            }
            
            canvas {
                margin: 10px auto;
            }
            
            .r2-checkbox-container {
                gap: 10px;
            }
            
            .r2-checkbox-label {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="r2-container">
        <h1 class="r2-h1">R² Visualisierung</h1>
        
        <div class="r2-checkbox-container">
            <label class="r2-checkbox-label">
                <input type="checkbox" id="r2-showResiduals" checked>
                <span>Residuenquadrate (RSS)</span>
            </label>
            <label class="r2-checkbox-label">
                <input type="checkbox" id="r2-showVariance" checked>
                <span>Varianzquadrate (TSS)</span>
            </label>
            <label class="r2-checkbox-label">
                <input type="checkbox" id="r2-showExplained" checked>
                <span>Erklärte Quadrate (ESS)</span>
            </label>
            <label class="r2-checkbox-label">
                <input type="checkbox" id="r2-showFitted" checked>
                <span>Fitted Values</span>
            </label>
        </div>
        
        <canvas id="r2-canvas" width="800" height="800"></canvas>
        
        <div class="r2-info-panel">
            <div class="r2-stats" id="r2-stats"></div>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('r2-canvas');
        const ctx = canvas.getContext('2d');
        
        let points = [];
        let draggedPoint = null;
        let offsetX = 0;
        let offsetY = 0;
        
        // Responsive canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(800, container.clientWidth - 30);
            
            canvas.width = maxWidth;
            canvas.height = maxWidth;
            
            updateCanvasDimensions();
            
            if (points.length > 0 || canvas.hasAttribute('data-initialized')) {
                draw();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Canvas settings
        let padding = 60;
        let plotWidth = 0;
        let plotHeight = 0;
        
        function updateCanvasDimensions() {
            padding = Math.max(40, canvas.width * 0.075);
            const availableSize = Math.min(canvas.width, canvas.height) - 2 * padding;
            plotWidth = availableSize;
            plotHeight = availableSize;
        }
        
        updateCanvasDimensions();
        
        // Coordinate system range
        let xMin = 0, xMax = 5;
        let yMin = 0, yMax = 5;
        
        // Convert canvas coordinates to plot coordinates
        function canvasToPlot(canvasX, canvasY) {
            updateCanvasDimensions();
            const x = xMin + (canvasX - padding) / plotWidth * (xMax - xMin);
            const y = yMax - (canvasY - padding) / plotHeight * (yMax - yMin);
            return { x, y };
        }
        
        // Convert plot coordinates to canvas coordinates
        function plotToCanvas(x, y) {
            const canvasX = padding + (x - xMin) / (xMax - xMin) * plotWidth;
            const canvasY = padding + (yMax - y) / (yMax - yMin) * plotHeight;
            return { canvasX, canvasY };
        }
        
        // Calculate regression and statistics
        function calculateStats() {
            if (points.length < 2) return null;
            
            const n = points.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumXY += p.x * p.y;
                sumX2 += p.x * p.x;
                sumY2 += p.y * p.y;
            });
            
            const meanX = sumX / n;
            const meanY = sumY / n;
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = meanY - slope * meanX;
            
            // Total sum of squares (TSS)
            let tss = 0;
            points.forEach(p => {
                const deviation = p.y - meanY;
                tss += deviation * deviation;
            });
            
            // Residual sum of squares (RSS)
            let rss = 0;
            points.forEach(p => {
                const predicted = slope * p.x + intercept;
                const residual = p.y - predicted;
                rss += residual * residual;
            });
            
            // Explained sum of squares (ESS)
            const ess = tss - rss;
            
            // R-squared
            const r2 = tss > 0 ? ess / tss : 0;
            
            return { slope, intercept, meanX, meanY, tss, rss, ess, r2 };
        }
        
        // Draw axes
        function drawAxes() {
            updateCanvasDimensions();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = Math.max(1, canvas.width / 400);
            const fontSize = Math.max(10, canvas.width / 60);
            ctx.font = fontSize + 'px Arial';
            ctx.fillStyle = '#333';
            
            const origin = plotToCanvas(0, 0);
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, origin.canvasY);
            ctx.lineTo(canvas.width - padding, origin.canvasY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(origin.canvasX, padding);
            ctx.lineTo(origin.canvasX, canvas.height - padding);
            ctx.stroke();
            
            // Tick marks and labels
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#999';
            ctx.fillStyle = '#666';
            
            // X-axis ticks
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                if (x === 0) continue;
                const pos = plotToCanvas(x, 0);
                ctx.beginPath();
                ctx.moveTo(pos.canvasX, origin.canvasY - 5);
                ctx.lineTo(pos.canvasX, origin.canvasY + 5);
                ctx.stroke();
                ctx.fillText(x.toString(), pos.canvasX - 5, origin.canvasY + 20);
            }
            
            // Y-axis ticks
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                if (y === 0) continue;
                const pos = plotToCanvas(0, y);
                ctx.beginPath();
                ctx.moveTo(origin.canvasX - 5, pos.canvasY);
                ctx.lineTo(origin.canvasX + 5, pos.canvasY);
                ctx.stroke();
                ctx.fillText(y.toString(), origin.canvasX - 25, pos.canvasY + 5);
            }
            
            // Axis labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('x', canvas.width - padding + 20, origin.canvasY);
            ctx.fillText('y', origin.canvasX, padding - 20);
        }
        
        // Draw mean line
        function drawMeanLine() {
            const stats = calculateStats();
            if (!stats) return;
            
            const start = plotToCanvas(xMin, stats.meanY);
            const end = plotToCanvas(xMax, stats.meanY);
            
            ctx.strokeStyle = '#d77d00';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(start.canvasX, start.canvasY);
            ctx.lineTo(end.canvasX, end.canvasY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label
            ctx.fillStyle = '#d77d00';
            ctx.font = 'bold 12px Source Sans Pro';
            ctx.fillText('ȳ = ' + stats.meanY.toFixed(2), start.canvasX + 5, start.canvasY - 8);
        }
        
        // Draw regression line
        function drawRegressionLine() {
            const stats = calculateStats();
            if (!stats) return;
            
            const y1 = stats.slope * xMin + stats.intercept;
            const y2 = stats.slope * xMax + stats.intercept;
            
            const start = plotToCanvas(xMin, y1);
            const end = plotToCanvas(xMax, y2);
            
            ctx.strokeStyle = '#267326';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start.canvasX, start.canvasY);
            ctx.lineTo(end.canvasX, end.canvasY);
            ctx.stroke();
        }
        
        // Draw variance squares (TSS)
        function drawVarianceSquares() {
            if (!document.getElementById('r2-showVariance').checked) return;
            
            const stats = calculateStats();
            if (!stats) return;
            
            points.forEach(point => {
                const pointPos = plotToCanvas(point.x, point.y);
                const meanPos = plotToCanvas(point.x, stats.meanY);
                
                const sideLength = Math.abs(pointPos.canvasY - meanPos.canvasY);
                
                ctx.fillStyle = 'rgba(215, 125, 0, 0.3)';
                ctx.strokeStyle = '#d77d00';
                ctx.lineWidth = 1;
                
                if (point.y > stats.meanY) {
                    ctx.fillRect(pointPos.canvasX, pointPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(pointPos.canvasX, pointPos.canvasY, sideLength, sideLength);
                } else {
                    ctx.fillRect(meanPos.canvasX, meanPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(meanPos.canvasX, meanPos.canvasY, sideLength, sideLength);
                }
            });
        }
        
        // Draw residual squares (RSS)
        function drawResidualSquares() {
            if (!document.getElementById('r2-showResiduals').checked) return;
            
            const stats = calculateStats();
            if (!stats) return;
            
            points.forEach(point => {
                const predictedY = stats.slope * point.x + stats.intercept;
                const pointPos = plotToCanvas(point.x, point.y);
                const predPos = plotToCanvas(point.x, predictedY);
                
                const sideLength = Math.abs(pointPos.canvasY - predPos.canvasY);
                
                ctx.fillStyle = 'rgba(0, 120, 165, 0.3)';
                ctx.strokeStyle = '#0078A5';
                ctx.lineWidth = 1;
                
                if (point.y > predictedY) {
                    ctx.fillRect(pointPos.canvasX - sideLength, pointPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(pointPos.canvasX - sideLength, pointPos.canvasY, sideLength, sideLength);
                } else {
                    ctx.fillRect(predPos.canvasX - sideLength, predPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(predPos.canvasX - sideLength, predPos.canvasY, sideLength, sideLength);
                }
            });
        }
        
        // Draw explained squares (ESS)
        function drawExplainedSquares() {
            if (!document.getElementById('r2-showExplained').checked) return;
            
            const stats = calculateStats();
            if (!stats) return;
            
            points.forEach(point => {
                const predictedY = stats.slope * point.x + stats.intercept;
                const predPos = plotToCanvas(point.x, predictedY);
                const meanPos = plotToCanvas(point.x, stats.meanY);
                
                const sideLength = Math.abs(predPos.canvasY - meanPos.canvasY);
                
                ctx.fillStyle = 'rgba(38, 115, 38, 0.3)';
                ctx.strokeStyle = '#267326';
                ctx.lineWidth = 1;
                
                if (predictedY > stats.meanY) {
                    ctx.fillRect(predPos.canvasX, predPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(predPos.canvasX, predPos.canvasY, sideLength, sideLength);
                } else {
                    ctx.fillRect(meanPos.canvasX, meanPos.canvasY, sideLength, sideLength);
                    ctx.strokeRect(meanPos.canvasX, meanPos.canvasY, sideLength, sideLength);
                }
            });
        }
        
        // Draw fitted values
        function drawFittedValues() {
            if (!document.getElementById('r2-showFitted').checked) return;
            
            const stats = calculateStats();
            if (!stats) return;
            
            const fittedRadius = Math.max(3, canvas.width / 200);
            
            points.forEach(point => {
                const predictedY = stats.slope * point.x + stats.intercept;
                const predPos = plotToCanvas(point.x, predictedY);
                
                ctx.beginPath();
                ctx.arc(predPos.canvasX, predPos.canvasY, fittedRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
        
        // Draw points
        function drawPoints() {
            const pointRadius = Math.max(5, canvas.width / 130);
            points.forEach(point => {
                const pos = plotToCanvas(point.x, point.y);
                
                ctx.beginPath();
                ctx.arc(pos.canvasX, pos.canvasY, pointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#267326';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = Math.max(2, canvas.width / 400);
                ctx.stroke();
            });
        }
        
        // Update statistics display
        function updateDisplay() {
            const stats = calculateStats();
            const statsDiv = document.getElementById('r2-stats');
            
            if (stats) {
                statsDiv.innerHTML = `
                    <div style="display: flex; gap: 20px; justify-content: space-between; align-items: center; flex-wrap: wrap;">
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <span style="color: #d77d00;"><strong>TSS:</strong> ${stats.tss.toFixed(2)}</span>
                            <span style="color: #267326;"><strong>ESS:</strong> ${stats.ess.toFixed(2)}</span>
                            <span style="color: #0078A5;"><strong>RSS:</strong> ${stats.rss.toFixed(2)}</span>
                        </div>
                        <span style="color: #267326;"><strong>R²:</strong> ${stats.r2.toFixed(4)}</span>
                    </div>
                `;
            } else {
                statsDiv.innerHTML = '<div>Mindestens 2 Punkte erforderlich</div>';
            }
        }
        
        // Main draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawAxes();
            drawMeanLine();
            drawRegressionLine();
            drawVarianceSquares();
            drawExplainedSquares();
            drawResidualSquares();
            drawFittedValues();
            drawPoints();
            updateDisplay();
        }
        
        // Event handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            
            for (let i = 0; i < points.length; i++) {
                const pos = plotToCanvas(points[i].x, points[i].y);
                const dist = Math.sqrt(Math.pow(canvasX - pos.canvasX, 2) + Math.pow(canvasY - pos.canvasY, 2));
                
                if (dist < 15) {
                    draggedPoint = i;
                    offsetX = canvasX - pos.canvasX;
                    offsetY = canvasY - pos.canvasY;
                    return;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (draggedPoint !== null) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left - offsetX;
                const canvasY = e.clientY - rect.top - offsetY;
                
                const plotCoords = canvasToPlot(canvasX, canvasY);
                plotCoords.x = Math.round(plotCoords.x / 0.2) * 0.2;
                plotCoords.y = Math.round(plotCoords.y / 0.2) * 0.2;
                
                points[draggedPoint] = plotCoords;
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            draggedPoint = null;
        });
        
        canvas.addEventListener('mouseleave', () => {
            draggedPoint = null;
        });
        
        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const canvasX = touch.clientX - rect.left;
            const canvasY = touch.clientY - rect.top;
            
            const touchRadius = Math.max(20, canvas.width / 50);
            for (let i = 0; i < points.length; i++) {
                const pos = plotToCanvas(points[i].x, points[i].y);
                const dist = Math.sqrt(Math.pow(canvasX - pos.canvasX, 2) + Math.pow(canvasY - pos.canvasY, 2));
                
                if (dist < touchRadius) {
                    draggedPoint = i;
                    offsetX = canvasX - pos.canvasX;
                    offsetY = canvasY - pos.canvasY;
                    return;
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedPoint !== null) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const canvasX = touch.clientX - rect.left - offsetX;
                const canvasY = touch.clientY - rect.top - offsetY;
                
                const plotCoords = canvasToPlot(canvasX, canvasY);
                plotCoords.x = Math.round(plotCoords.x / 0.2) * 0.2;
                plotCoords.y = Math.round(plotCoords.y / 0.2) * 0.2;
                
                points[draggedPoint] = plotCoords;
                draw();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            draggedPoint = null;
        });
        
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            draggedPoint = null;
        });
        
        // Checkbox event listeners
        document.getElementById('r2-showResiduals').addEventListener('change', draw);
        document.getElementById('r2-showVariance').addEventListener('change', draw);
        document.getElementById('r2-showExplained').addEventListener('change', draw);
        document.getElementById('r2-showFitted').addEventListener('change', draw);
        
        // Initial points (3 points as in GeoGebra app)
        points = [
            { x: 0.6, y: 0.4 },
            { x: 3, y: 3 },
            { x: 4.5, y: 2.2 }
        ];
        
        canvas.setAttribute('data-initialized', 'true');
        resizeCanvas();
        draw();
    })();
    </script>
</body>
</html>
````